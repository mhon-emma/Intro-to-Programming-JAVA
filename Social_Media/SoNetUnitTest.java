/*-----------------------------------------------------------------------------
author: James Taylor

This program performs unit testing on the SocialNet class.  
------------------------------------------------------------------------------*/
import java.awt.*;
import java.awt.image.*;
import java.lang.*;
import java.util.*;


public class SoNetUnitTest {
    // The master list of posts
    public static int[][] posts;

    // The referential views of posts generated by different sorts
    public static int[][] view1;    // base iterative sort
    public static int[][] view2;    // ext recursive sort

    // The profiling data gathered during a sort
    public static int[] profile1;   // base iterative sort profile
    public static int[] profile2;   // ext recursive sort

    // ------------------------------------------------------------------------
    // Entry Point
    // ------------------------------------------------------------------------
    /// Entry Point.  The main program executes a set of UnitTests on the 
    /// various methods in the Steganography class to test different levels of 
    /// functionality.
    public static void main (String[] argv) {
        // Using global variables here which is discouraged unless you 
        // understand exactly why.  In general, you should not follow this model
        // unless you have very good reason.  The reason that it is acceptable
        // here is that this is a test suite, the work is all done here in this
        // function, and the test functions only read the contents of the 
        // variables.  If most of this criteria is not met, then a global 
        // variable is likely a huge mistake.
        posts = PostReader.getPosts("posts");
        view1 = SocialNet.createView(posts);
        view2 = SocialNet.createView(posts);
        String s;

        // --------------------------------------------------------------------
        if( testPostLength() ) {
            System.out.println("testPostLength(initial) succeeded");
        } else {
            System.out.println("testPostLength(initial) failed");
        }

        if( testPostOrder() ) {
            System.out.println("testPostOrder(initial) succeeded");
        } else {
            System.out.println("testPostOrder(initial) failed");
        }

        if( testDifferential() ) {
            System.out.println("testDifferential succeeded");
        } else {
            System.out.println("testDifferential failed");
        }

        if( testLessThan() ) {
            System.out.println("testLessThan succeeded");
        } else {
            System.out.println("testLessThan failed");
        }

        if( testSwap() ) {
            System.out.println("testSwap succeeded");
        } else {
            System.out.println("testSwap failed");
        }

        // --------------------------------------------------------------------
        profile1 = SocialNet.iterativeSort(view1);

        if( testBaseSort() ) {
            System.out.println("testBaseSort succeeded");
        } else {
            System.out.println("testBaseSort failed");
        }

        if( testPostLength() ) {
            System.out.println("testPostLength(after base sort) succeeded");
        } else {
            System.out.println("testPostLength(after base sort) failed");
        }

        if( testPostOrder() ) {
            System.out.println("testPostOrder(after base sort) succeeded");
        } else {
            System.out.println("testPostOrder(after base sort) failed");
        }

        // --------------------------------------------------------------------
        profile2 = SocialNet.recursiveSort(view2);

        if( testExtensionSort() ) {
            System.out.println("testExtensionSort succeeded");
        } else {
            System.out.println("testExtensionSort failed");
        }

        if( testPostLength() ) {
            System.out.println("testPostLength(after ext sort) succeeded");
        } else {
            System.out.println("testPostLength(after ext sort) failed");
        }

        if( testPostOrder() ) {
            System.out.println("testPostOrder(after ext sort) succeeded");
        } else {
            System.out.println("testPostOrder(after ext sort) failed");
        }

        // --------------------------------------------------------------------
        if( testCompareSorts() ) {
            System.out.println("testCompareSorts succeeded");
        } else {
            System.out.println("testCompareSorts failed");
        }

        reportProfileData();
    }

    // ------------------------------------------------------------------------
    /// The data has 10k records.  This just makes sure the file is big enough
    /// to be a large dataset
    public static boolean testPostLength() {
        // make sure that posts has at least 10000 entries
        if( posts.length < 10000 ) {
            System.out.println("ERROR: posts length too small");
            return false;
        } 
        return true;
    }

    // ------------------------------------------------------------------------
    /// This test verifies that a sorting is performed on the references 
    /// (shallow) and not on the values (deep).  A view is simply a reordering
    /// of the rows and not a full copy of the original post data.  Our data is
    /// just a snapshot at one point in time.  There may be millions of users
    /// making changes at a fast pace and we would like to resort the views 
    /// with updated info from the posts as this information is relatively 
    /// sorted rather than have to realloc over and over. 
    public static boolean testPostOrder() {
        // make sure that posts ids remain in default post id order
        for(int i = 0; i < posts.length; i++) {
            //System.out.println(i + ","  + posts[i][0]);
            if( posts[i][0] != i+1 ) {
                System.out.println("ERROR: post sequencing changed " + i + "," + posts[i][0]);
                return false;
            }
        }
        return true;
    }

    // ------------------------------------------------------------------------
    /// Validates that the differential operation computes the correct value
    public static boolean testDifferential() {
        int[] p = {0,1,0};  // positive differential
        int[] z = {0,1,1};  // zero differential
        int[] n = {0,0,1};  // negative differential

        if( SocialNet.differential(p) != 1 ) {
            return false;
        }
        if( SocialNet.differential(z) != 0 ) {
            return false;
        }
        if( SocialNet.differential(n) != -1 ) {
            return false;
        }

        return true;
    }
    // ------------------------------------------------------------------------
    /// Validates that the less than operation operates correctly on the 
    /// virtual differential field
    public static boolean testLessThan() {
        int[] p = {0,1,0};  // positive differential
        int[] z = {0,1,1};  // zero differential
        int[] n = {0,0,1};  // negative differential

        // - Positive against Zero tests -
        // left op should not be less than right op
        if( SocialNet.lessThan(p,z) ) {
            //System.out.println("Failed: p < z -> false");
            return false;
        }
        // left op should be less than right op
        if( !SocialNet.lessThan(z,p) ) {
            //System.out.println("Failed: z < p -> true");
            return false;
        }

        // - Zero against Negative tests -
        // left op should not be less than right op
        if( SocialNet.lessThan(z,n) ) {
            //System.out.println("Failed: z < n -> false");
            return false;
        }
        // left op should be less than right op
        if( !SocialNet.lessThan(n,z) ) {
            //System.out.println("Failed: n < z -> true");
            return false;
        }

        // - Positive against Negative tests -
        // left op should not be less than right op
        if( SocialNet.lessThan(p,n) ) {
            //System.out.println("Failed: p < n -> false");
            return false;
        }
        // left op should be less than right op
        if( !SocialNet.lessThan(n,p) ) {
            //System.out.println("Failed n < p -> true");
            return false;
        }

        // - Equal to test -
        // left op should not be less than right op
        if( SocialNet.lessThan(p,p) ) {
            //System.out.println("Failed: z < z -> false");
            return false;
        }

        return true;
    }

    // ------------------------------------------------------------------------
    /// Validates that swap is referential (shallow)
    public static boolean testSwap() {
        int[][] orig = {{0},{1}};
        int[][] test = new int[2][];

        // copy the original references
        for(int i = 0; i < 2; i++) {
            test[i] = orig[i];
        }
    
        // perform the swap
        SocialNet.swapPosts(test, 0, 1);

        // follow the row references and verify that the values that are 
        // referenced are reversed
        if( test[0][0] != 1 || test[1][0] != 0 ) {
            return false;
        }

        // verify that the addresses of the swapped "rows" refer to the same 
        // original rows
        if( test[0] != orig[1] || test[1] != orig[0] ) {
            return false;
        }
        return true;
    }

    // ------------------------------------------------------------------------
    /// Validates that the base sorting method using a simple assumption built
    /// into the posts file test data... 
    /// posts file test data was generted using randomization.  File was tweaked
    /// to guarantee that no neighbor in posts should remain a neighbor once 
    /// sorted and that the same sequence will be generated regardless of sort 
    /// used.  
    public static boolean testBaseSort() {
        if( view1 == null ) {
            System.out.println("ERROR: view1 is null");
            return false; 
        }

        if( view1.length != posts.length ) {
            System.out.println("ERROR: view1 length too small");
            return false;
        }

        // neighboring posts in a sorted view cannot be sequential in test data
        for(int i = 1; i < view1.length; i++) {
            if( view1[i][0] == view1[i-1][0] + 1 ) {
                //System.out.println("id: " + view1[i-1][0]);
                System.out.println("id: " + view1[i][0]);
                //System.out.println("id: " + view1[i][0]);
                return false;
            }
        }
        return true;
    }

    // ------------------------------------------------------------------------
    /// Validates that the ext sorting method using a simple assumption built
    /// into the posts file test data... 
    /// posts file test data was generted using randomization.  File was tweaked
    /// to guarantee that no neighbor in posts should remain a neighbor once 
    /// sorted and that the same sequence will be generated regardless of sort 
    /// used.  
    public static boolean testExtensionSort() {
        if( view2 == null ) {
            System.out.println("ERROR: view2 is null");
            return false; 
        }

        if( view2.length != posts.length ) {
            System.out.println("ERROR: view2 length too small");
            return false;
        }

        // neighboring posts in a sorted view cannot be sequential in test data
        for(int i = 1; i < view2.length; i++) {
            if( view2[i][0] == view2[i-1][0] + 1 ) {
                //System.out.println("id: " + view2[i][0]);
                return false;
            }
        }
        return true;
    }

    // ------------------------------------------------------------------------
    /// Validates that the two sorts produce the same sorted output
    /// posts file test data was generted using randomization.  File was tweaked
    /// to guarantee that no neighbor in posts should remain a neighbor once 
    /// sorted and that the same sequence will be generated regardless of sort 
    /// used.  
    public static boolean testCompareSorts() {
        if( view1 == null ) {
            System.out.println("ERROR: view1 is null");
            return false; 
        }

        if( view2 == null ) {
            System.out.println("ERROR: view2 is null");
            return false; 
        }

        if( view1.length != view2.length ) {
            System.out.println("ERROR: view lengths do not match");
            return false;
        }

        // test data should ensure that regardless of sort the sorted data will
        // have the same order.  This compares the ids in two views and verifies
        // that they are the same
        boolean result = true;
        for(int i = 0; i < view1.length; i++) {
            if(view1[i][0] != view2[i][0]) {
                //System.out.println("i: " + i + ", id: " + view1[i][0] + ", delta: " + SocialNet.differential(view1[i]));
                result = false;
            }
        }

        return result;

        // Note: this test is designed to delay return until sampling all data
        // so that we can see all matches.
    }

    // ------------------------------------------------------------------------
    /// Reports profile information returned by sorts to the console
    public static void reportProfileData() {
        String s;

        if( profile1 == null ) {
            System.out.println("ERROR: profile1 is null");
            return;
        }
        if( profile1.length != 3 ) {
            System.out.println("ERROR: profile1 has an unexpected shape");
            return;
        }
        s = "iterativeSort::allocs:" + profile1[0];
        s += ", compares:" + profile1[1];
        s += ", swaps:" + profile1[2];
        System.out.println(s);

    
        if( profile2 == null ) {
            System.out.println("ERROR: profile2 is null");
            return;
        }
        if( profile2.length != 3 ) {
            System.out.println("ERROR: profile2 has an unexpected shape");
            return;
        }
        s = "recursiveSort::allocs:" + profile2[0];
        s += ", compares:" + profile2[1];
        s += ", swaps:" + profile2[2];
        System.out.println(s);
    }
}
